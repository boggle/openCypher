= CIP2015-06-24 Calling Procedures
:numbered:
:toc:
:toclevels: 3
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>
*Author:* Nigel Small <nigel.small@neotechnology.com>
*Author:* Rickard Öberg <rickard.öberg@neotechnology.com>

[abstract]
.Abstract

This proposal introduces procedures as a new concept to Cypher and proposes a new facility for calling them.

User-defined functions are a separate concern that might be addressed in a future CIP.

toc::[]

== Motivation & Background

While Cypher is a very expressive graph query language, its declarative nature and scope is currently not sufficient for expressing certain classes of graph traversals, such as traversals relying on using specialized data structures or accessing third-party functionality.

This CIP proposes adding procedures to Cypher in order to address these issues.

== Proposal

This proposal consists of two parts, introducing procedures conceptually, and describing how to call them in a
system that supports Cypher.


=== Procedures

A procedure has a name and takes a fixed number of named and typed arguments in a fixed sequence.
A procedure yields a stream of result records and may potentially cause a side effect.

Each record yielded contains values for the same fixed number of named and typed fields in the same fixed sequence such that each field value in a yielded record matches its field's type.

The name of a procedure, its argument names, and if applicable any result field names follow the same rules as other symbolic names in Cypher (like variables, labels, relationship types, and property keys).


==== Procedure signatures

The arguments of a procedure, their types, and their order are called its *argument signature*.

The result fields of returned records, their types, and their order are called its *result signature*.

Together, the argument signature and the result signature form the (full) *signature* of a procedure.

According to this definition, a procedure may take zero arguments and/or may yield records with zero result fields.

==== Procedure signature notation

This CIP suggests a standard notation for printing procedure names together with their signatures.
This notation may be used in system monitoring, documentation and error reporting, and perhaps more importantly is to be used in future CIPs.
It is based on the syntax for type annotations as specified by the Cypher type system:

- Procedures returning a stream of records: `<procName>(arguments) :: (results)`
- Arguments and results are written as comma-separated lists of `<name> :: <type>`

An actual implementation may choose to support a notion of default value for procedure arguments.
For such a case, this CIP proposes that arguments with default values are written as `<name> = <value> :: <type`.

==== Procedure implementation

In an actual implementation, procedures may be written in different programming languages and provided with APIs for accessing the underlying graph database or graph processing system as appropriate.
The details of this are outside the scope of this proposal.

=== Procedure calls

Procedures are called for each incoming record produced by preceding clauses and each time produce arbitrarily many result records.
If a statement starts with a procedure call, this call is executed once, i.e. procedure calls behave similarly to `UNWIND` regarding how they change the result cardinality.

We propose new syntax that introduces a new clause for calling procedures.
This clause for calling procedures starts with the `CALL` keyword.
Next follows the actual call (i.e. procedure name and arguments in signature order).
Finally (and optionally) the clause may end with the `YIELD` keyword followed by any chosen result field projections.

A procedure call constitutes either an entire Cypher statement (i.e. a "standalone call"), or is called as part of a larger query (i.e. an "in-query call").
These different calling modes are detailed in the following subsections.

==== In-query calls

Calling a procedure as part of a larger query follows three basic rules:

- All arguments are always passed explicitly in the order given by the signature.
- Result fields are projected and appended as new variable bindings explicitly through the use of the `YIELD` keyword.
- New variable bindings projected from result fields are not allowed to shadow existing variable bindings that are already in scope.

These rules ensure that looking at a procedure call provides enough information to ascertain its impact on the variable scope in its part of the query without having to be aware of any other previously bound variables.

As a basic example, consider a call to the procedure `myProc(name``::``STRING?``,``id``::``INTEGER?)``::`` (last``::``STRING?)`:

.Calling procedure inside a larger query
[source, cypher]
----
MATCH (n:Person)-[r:IN]->(g:Group)
CALL myProc(n.name, g.id * 1000 + r.id) YIELD last AS lastLogin
RETURN *
----

This calls `myProc` for each record produced by the preceding `MATCH` clause with a `name` argument obtained by evaluating `n.name` and an `id` argument obtained by evaluating `g.id * 1000 + r.id`.
Each call may yield multiple procedure result records with a single result field `last`.
For each of them, a new statement result record is created that contains the original variables already in scope (i.e. `n`, `r`, `g`) as well as the projected result field `last` renamed as `lastLogin`.

Omitting the `YIELD` subclause means that no new variables are introduced into the scope.
The procedure call will still affect the cardinality.
This means that if the procedure returns 5 rows, the incoming row will be repeated 5 times.

The `YIELD` subclause is *always* omitted if the procedure returns only records with no result fields (i.e. is of type `()`).

==== Standalone calls

Procedures may also be called standalone, i.e. without taking arguments from or combining their results with other parts of a larger query.
In this case, the trailing `RETURN` clause is omitted and all fields projected in the `YIELD` subclause of the `CALL` statement are implicitly returned by the query.
A further simplification allowed in the standalone form is to use `YIELD *` to denote that all fields returned by the procedure are to be returned by the query.
The `YIELD *` form is _only_ allowed in the standalone form of `CALL`.

If the `YIELD` subclause is omitted in the standalone form of `CALL`, the semantics are the same as in the _in-query_ form, i.e. the query will not project any fields into the result, but the query will still return as many (empty) rows as produced by the called procedure.

Again consider a call to the procedure `myProc(name``::``STRING?``,``id``::``INTEGER?)``::`` (last``::``STRING?)`:

.Calling procedure as a standalone call statement
[source, cypher]
----
CALL myProc('Donald', $id) YIELD *
----

The above example would call `myProc` with the constant argument `'Donald'` for the `name` parameter, and use the query parameter `id` as the `id` argument of the procedure.
All the returned fields would then be bound and returned by the query.

If we instead consider the procedure `listProcedures()``::`` (name``::``STRING?, arguments``::``STRING?, result``::``STRING?)`:

.Calling procedure as a standalone call statement
[source, cypher]
----
CALL listProcedures() YIELD name AS procedure
----

The above example would return the name of each procedure known to the system in a column called `procedure`.

=== Procedure call semantics

The technical details of how procedure calls are executed are left to the implementation as long as they do not violate
the following rules:

It is an error if calling a procedure fails to yield results in accordance with its declared result signature.

If calling a procedure yields records, these records are yielded from the Cypher statement (or clause resp.) for the procedure call in the same order as they are yielded by the procedure.

If a procedure call fails to execute (i.e. it "throws an exception"), this error is propagated to the user in the same way as other runtime errors are propagated to the user by the implementation.

If executing a procedure call causes any side effects (i.e. it "updates the graph"), all such changes should be executed
before any results are returned to the user.
An implementation may provide the user with a way to opt out of this behavior, however this must be done explicitly (e.g. via a configuration setting).

==== Semantics of argument passing

Arguments are provided as a sequence of expressions as required by the procedure's signature.
It is an error if the number of provided arguments differs from the number of arguments required by the procedure signature.

To call the procedure, all argument expressions are evaluated to argument values in order.
It is an error if the argument values are incompatible with the argument types required by the procedure signature.

=== About `YIELD *`

`YIELD *` is only allowed in the standalone form of `CALL`.
The reason why `YIELD *` is not allowed in the _in-query_ form of `CALL` is because it makes it hard for a reader of the query (and for query analysis tools) to reason about the scope of variables, since it does not make it explicit which variables are introduced.
This makes later variable references in the query potentially ambiguous about whether they are introducing a new variable or just referencing a variable introduced by `YIELD *`.
To avoid these ambiguities `YIELD *` is disallowed within queries.

However, for queries that are made up solely by a single CALL, YIELD * is not ambiguous since there are no further clauses that could reference variables.
Given the convenience of not having to explicitly list all the returned fields in the `YIELD` subclause, in particular for interactive queries, it is deemed a valuable special case to allow `YIELD *` in the standalone form of `CALL`.

== What others do

The https://docs.google.com/document/d/1t_MqE9e8cCcvW3YoHuP-aX2XSub15ksbeu2psRCTozY/edit?usp=sharing[stored procedures survey] is extremely comprehensive, examining how procedures are
implemented and deployed as well as their API access mechanisms and usage.
Products surveyed include PostgreSQL, MS SQL Server, Oracle, MySQL, MongoDB, Aerospike and Virtuoso.

== Benefits to this proposal

The benefits of having user-defined procedures is so that users would be able to implement algorithms and functionality
which Cypher either cannot express or which cannot be executed efficiently by current Cypher implementations. Additionally, users may find procedures to be a useful mechanism to achieve good system design and code abstraction.

== Caveats to this proposal

Procedures are a powerful extension mechanism.
Their introduction opens up new ways of using Cypher which over time may lead to suboptimal usage patterns and hard to read queries.
The introduction of procedures therefore carries a risk of influencing the long term evolution of the language in a negative way.

== Appendix: Calling modes

.Calling modes
[frame="topbot",cols="2l,1a,1m", options="header,footer"]
|============================================================
|Statement template                  |Mode      |New Bindings
|[...] CALL proc(..) YIELD .. [...]  |In-Query  |Some
|[...] CALL proc(..) [...]           |In-Query  |None
|CALL proc(..) YIELD *               |Standalone|All
|CALL proc(..) YIELD ..              |Standalone|Some
|CALL proc(..)                       |Standalone|None
|============================================================

Legend:

* Mode
  - `In Query`: The procedure call is part of a larger query (or statement)
  - `Standalone`: The procedure call forms the whole query / statement
* New bindings:
  - `None`: The call may not bind new variables
  - `Some`: The call may bind new variables
  - `All`:  The call will bind all returned fields into variables
