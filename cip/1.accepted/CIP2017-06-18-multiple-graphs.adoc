= CIP2017-06-18 - Multiple Graphs
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>

This material is based on internal contributions of Alastair Green <alastair.green@neotechnology.com>, Mats Rydberg <mats.rydberg@neotechnology.com>, Martin Junghanns <martin.junghanns@neotechnology.com>, Tobias Lindaaker <tobias.lindaaker@neotechnology.com>.

[abstract]
.Abstract
--
This CIP proposes to extend Cypher with support for the construction, transformation, and querying of multiple graphs by adopting the proposed multiple property graphs model and by adopting a new execution model that is called the multiple graphs execution model and by introducing new syntax for working with multiple graphs.
--

toc::[]

== Motivation

Cypher today is a query language for property graphs that provides access to a single, global, implicit graph in order to extract, transform, and return tabular data that is derived from it.
While such returned tabular data may include graph entities (such as nodes and relationships), in essence Cypher as a language is not closed under graphs and as a consequence, Cypher queries are not yet (graph) compositional.

However it seems desirable that a language for property graphs should not only enable querying and updating a selected graph but should also support the construction and transformation of multiple graphs, ideally by utilizing a mechanism for incremental query composition.

Furthermore, adding support for working with multiple graphs has recently been identified as a frequently requested feature:

* It would enable the dynamic construction of graph views (e.g. for access control)
* It allows reasoning over multiple versions of the same graph (e.g. comparing daily snapshots)
* It may provide a great grouping mechanism for naturally partitioned data (e.g. per-continent graph)
* It could be used for combining data from disparate data sources in one system (e.g. in federation and data integration scenarios)
* It fits the paradigm of prominent analytical big-data processing systems (like e.g. Apache Spark)
* It mirrors mathematical graph theory where working with multiple graphs is standard

== Background and Overview

This proposal needs to modify and extend different aspects of the language consistently.

Therefore background material regarding current semantics is given in line with the different individual sections of this proposal.

== Proposal: Multiple Property Graphs Model

Before proposing changes to the language, it is necessary to first address required changes to the underlying https://github.com/opencypher/openCypher/blob/master/docs/property-graph-model.adoc[*property graph model*].

The revised property graph model used in this CIP is called the *multiple property graphs model* and assumes everything specified in the original property graph model extended with the notion of multiple, optionally overlapping graphs outlined in the following.

=== Model definition

This CIP defines an instance of the *multiple property graphs model* to be a set of property graphs that adhere to the definitions given below.

=== (Property) Graph

_Definition_ A *property graph* is a set of labeled nodes and typed relationships both together with their properties (a property is a tuple of a named key and a value).
Graphs may be updatable, i.e. the set of contained nodes and relationships may change during the lifetime of the graph.
It is an error to attempt to update a read-only graph.

The same node or relationship may be part of many graphs.
A relationship may only be part of a graph if its start node and its end node are both also part of the same graph.
Therefore removing a node from a graph will require removing all of its relationships from the graph, too.
An entity is considered to be deleted if it is no longer part of any graph.

=== Graph Addressing

Graphs do not expose an identity like nodes or relationships do.

Graphs may be made addressable through other means by a conforming implementation, e.g. through exposing the graph under a _graph URL_ for referencing and loading it.
The details regarding the format and choice of graph URLs is outside the scope of this proposal.

A graph is considered to have been deleted if it is no longer registered under a graph URL and no other reference to it is retained, e.g. from a running query.

== Background: Single Graph Execution Model

To describe the foundational shift proposed by this CIP, we'll define some terminology for describing the state that is manipulated by Cypher's current single graph execution model.

A Cypher query currently takes a set of parameters as input, queries a single, global, implicit property graph, potentially updates it, and finally returns tabular data derived from it.
Query parameters are conceptually thought to be inlined before the start of query execution.
Therefore the *execution context* of a whole Cypher query is a single, global, implicit property graph.

Each sequence of clauses (sometimes called a *pipeline*) optionally operates on this single implicit graph and takes a single table input in order to produce a new single table output.
Furthermore, Cypher supports query combinator clauses like `UNION` and `UNION ALL` for merging two pipelines into one.
Therefore the *query context* that conceptually is passed between clauses in the single graph execution model is simply a single table.

With this terminology in place, execution of a parameterized Cypher query in the single graph execution model can be described as executing within (and operating on) a given execution context and an initial query context and finally returning the query context produced as output for the top-most `RETURN` clause.

Note: This formulation is introduced to describe a high-level model for the execution of queries; a real world implementation is free to choose any other internal representation (e.g. based on an algebra) as long as it does not violate the specified semantics.

== Proposal: Multiple Graphs Execution Model

In the single graph execution model, tabular data serves as the basis of iteration while the single implicit global graph serves as the basis of graph matching and graph manipulation.

This section introduces the *multiple graphs execution model* as an evolution of the *single graph execution model* that enables the addition of features to the language for working with multiple graphs, i.e. it changes the basis of graph matching and graph manipulation.

This CIP proposes the adoption of the multiple graphs execution model by Cypher and to execute existing, single graph queries under this model as outlined below.

=== Model definition

This CIP proposes to redefine the *execution context* to be

* a set of graphs in the multiple graphs execution model
* a special graph drawn from this set that is called the *default graph*

This CIP proposes to redefine the *query context* to be

* a set of named graphs from the *execution context*
* an optional information that indicates which of these named graphs if any is the *source graph*
* an optional information that indicates which of these named graphs if any is the *target graph*
* optional *tabular data*, i.e. a potentially ordered bag of records, each having the same fixed set of fields

These redefinitions constitute the multiple graphs execution model. A parameterized Cypher query under this model can _also_ be described as executing within (and operating on) a given execution context and an initial query context and finally returning the query context produced as output for the top-most `RETURN` clause.

As a consequence of adopting the new multiple graphs execution model, the semantics of each clause needs to be (re-)defined as to how the execution of the clause transforms all given input query contexts into an output query context.
This CIP preserves all existing semantics by defining how to simulate the single graph execution model in the multiple graphs execution model as outlined below.

=== Partial query contexts

A query context may _not_ return a source graph, a target graph, or even tabular data.
Such a query context is called a *partial query context*.
The following rules are proposed to provide defaults for executing a query (or a clause) on a partial query context:

If the input query context of a query (or a clause) does not return a source graph, the *provided source graph* of that query is taken to be the default graph.

If the input query context of a query (or a clause) does not return a target graph, the *provided target graph* of that query is taken to be the default graph.

If the input query context of a query (or a clause) does not return tabular data, the *provided tabular data* of that query is taken to be a single record without any fields.

These rules ensures that a follow-up query (or a clause) that is executed on a partial query context is always provided with a source graph for graph matching, a target graph for graph manipulation, and tabular data such that it will iterate over at least one row.

=== Query composition

The multiple graphs execution model provides a natural way for the sequential composition of queries:

A query `Q1` whose output signature is an acceptable (in terms of provided bindings) input signature for another query `Q2` may be composed sequentially with `Q2` into a new query `Q3` that first runs `Q1` on the initial query context, next runs `Q2` on the query context returned by `Q1`, and finally returns the query context returned by `Q2`.

This homogenous query composition is enabled by using a uniform query context that is passed between clauses.

Note: The currently drafted subquery CIP proposes a language addition (e.g. `THEN`) for expressing this kind of query composition directly. In terms of this CIP, `THEN` is simply syntactic sugar for `WITH * GRAPHS *`

=== Query combinators

Query combinators only need to handle tabular query contexts in the single graph execution model.

For the multiple property graphs execution model, it is necessary to define how query combinators combine the query contexts of all child queries into a new result query context (c.f. query composition).

This CIP proposes that the multi-arm query combinators `UNION` (and `UNION ALL` respectively) combine their contexts according to the following rules:

* Tabular data is combined as today, i.e. the tabular result is either a concatenation (`UNION ALL` case) or a distinct union (`UNION` case) of the tabular data from both arms
*  All graphs from both arms are returned; if both arms return a graph with the same name, then the union of those graphs is returned under the shared name
* If both graphs have specified a graph with the same name as their current source graph, then the union of those source graphs under that name again becomes the source graph for further processing.
Otherwise, the next source graph will be again the default graph.
* If both graphs have specified a graph with the same name as their current target graph, then the union of those target graphs under that name again becomes the target graph for further processing.
Otherwise, the next target graph will be again the default graph. 

=== Updating queries

This CIP proposes the following update semantics for Cypher with support for multiple graphs:

* All updating clauses update the provided target graph of their current query context.
  More concretely:
  ** Entities are always created in and deleted from the currently provided target graph.
  ** All entities of bound pattern variables in `CREATE` and `MERGE` are always added to the provided target graph of the current query context.
  ** Deleting an entity only affects the provided target graph of the current query context.
* Updating queries always return all variables and graphs in scope, i.e. the behave as if they would end in `RETURN * GRAPHS *` (This syntax is introduced below).
* Semantically, all effects of an updating clause must be made visible before proceeding with the execution of the next clause.
In other words, a conforming implementation must ensure that a later clause alway sees the complete set of updates of a preceding updating clause.
* A single update clause may perform multiple conflicting updates on the same node or relationship.
In this situation, the outcome is undefined.
Conflicting updates are considered to be out of scope of this CIP and will be addressed in a future proposal.
For now it is proposed that a conforming implementation must choose at least either the original value or one of the values written or `NULL` as the final outcome of a conflicting update.

=== Simulating the single graph execution model

Execution under the single graph execution model can be simulated in the multiple graphs execution model by executing the query in an execution context that uses the single graph as the default graph and by running it on an empty initial query context.

== Proposal: Multiple Graphs Syntax

As a first language addition, this CIP proposes syntax for changing the source and the target graph of the current query context:

[source, cypher]
----
FROM < graph-specifier >
INTO < graph-specifier >
----

=== FROM clause

The newly introduced `FROM` clause may be used to change both the source and the target graph of the current query context to the graph described by the given `<graph-specifier>`.

=== INTO clause

The newly introduced `INTO` clause may be used to change the target graph of the current query context to the graph described by the given `<graph-specifier>`.

=== Graph specifiers

This CIP defines the notion of `<graph-specifier>` as a means to introduce, refer to, and alias named graphs.

This CIP proposes the following kinds of graph specifiers:

* `NEW GRAPH [<new-graph-name>] [AT <graph-url>]`: Reference to a newly created, empty graph that is to be bound as `<new-graph-name>` and may potentially overwrite any pre-existing graph at the provided `<graph-url>`
* `GRAPH [<new-graph-name] AT <graph-url>`: Reference to the graph at the given `<graph-url>` that is to be bound as `<new-graph-name>`
* `[GRAPH] <graph-name> [AS <new-graph-name>]`: Reference to an already bound named graph
* `COPY [GRAPH] <graph-name> [AS <new-graph-name>]`: Reference to a copy of an already bound named graph
* `SOURCE GRAPH [<new-graph-name>]`: Reference to the currently _provided source graph_, optionally to be bound as `<new-graph-name>`
* `TARGET GRAPH [<new-graph-name>]`: Reference to the currently _provided target graph_, optionally to be bound as `<new-graph-name>`

If a graph specifier is not referencing an already bound named graph and does not specify a `<new-graph-name>`, it is bound to a fresh system generated name.
The details of this are left to implementations.

It is an error to use a `<graph-specifier>` in a context where its introduced `<new-graph-name>` is already bound.

==== Graph names

Graph names use the same syntax as existing variable names.

It is an error to use the same name for both a regular variable or the name of a graph.

==== Graph URLs

The exact shape and form of graph URL lies outside the scope of this CIP.

This CIP however proposes that a `<graph-url>` must always be given as either a string literal or a query parameter.

This allows parameterization of queries by controlling which graphs from which graph URLs they should use.

=== Changing back to no graph

Additionally, this CIP proposes new syntax for discarding the source and the target graph of the current query:

[source, cypher]
----
FROM -
INTO -
----

`-` is not a graph specifier; rather this syntax is a special form for discarding the current source and target graph such that the provided source and target graph are again chosen to be the default graph as specified for partial query contexts.

In consequence, both `FROM -` and `INTO -` will not bind the default graph to a generated fresh name.
This is different from `<graph-specifier>` semantics that will ensure that referenced graphs are always bound to a name.

=== Returning, aliasing, and selecting graphs

This CIP proposes to extend both the `WITH` and the `RETURN` clauses with new syntax for controlling the set of available named graphs that should be passed on by the clause (or returned from the query respectively) by explicitly specifying all `<graph-return-items>`.
The newly proposed syntax is:

[source, cypher]
----
WITH [ < return-items > ] [ [ INPUT ] GRAPHS < graph-return-items > ]
RETURN [ < return-items > ] [ [ INPUT ] GRAPHS < graph-return-items > ]
----

This CIP proposes the following kinds of `<graph-return-items>`:

* `<graph-specifier-list>`: A comma separated list of `<graph-specifier>` that are to be passed on
* `*`: All named graphs are to be passed on
* `*, <graph-specifier-list>`: All named graphs are to be passed on together with any additional named graphs that are newly bound in `<graph-specifier-list>`
* `-`: No named graphs are to be passed on

The order of named graphs inherently given by `<graph-return-items>` is semantically insignificant.
However it is recommended that conforming implementations preserve this order at least in programmatic output operations (e.g. a textual display of the list of returned graphs).
This in essence mirrors the semantics for tabular data returned by Cypher.

Both `WITH ... GRAPHS ...` and `RETURN ... GRAPHS ...` will pass on (or return respectively) exactly the set of described named graphs.
To simplify passing on available graphs it is proposed by this CIP that regular `WITH <return-items>` is taken to be syntactic sugar for `WITH <return-items> GRAPHS -` and that regular `RETURN <return-items>` is taken to be syntactic sugar for `RETURN <return-items> GRAPHS -`.

To even further simplify, it is additionally proposed that `WITH|RETURN <return-items> INPUT GRAPHS <graph-return-items>` is to be syntactic sugar for `WITH|RETURN <return-items> GRAPHS <graph-return-items>, SOURCE GRAPH, TARGET GRAPH`.
However if `<graph-return-items>` already passes on a reference for the `SOURCE GRAPH`, no additional reference for it is added and if `<graph-return-items>` already passes on a reference for the `TARGET GRAPH`, no additional reference for it is added.

If the current named source graph (or the current named target graph) are not passed on, they are discarded and due to the rules regarding partial query contexts the provided source graph (or target respectively) again are chosen to be the default graph of the outer execution context.

Note: `WITH <return-items> GRAPHS *` may be used to pass through the initial query context without having to alias incoming source and target graphs explicitly.

=== Discarding available tabular data

It is additionally proposed that both `WITH GRAPHS <graph-return-items>` and `RETURN GRAPHS <graph-return-items>` are syntactic sugar for `WITH - GRAPHS <graph-return-items>` (and `RETURN - GRAPHS <graph-return-items>` respectively).
These special forms may be used for discarding all tabular data such that the provided tabular input for the following clause (or query respectively) would again be the provided single record without any fields as specified by the rules for partial query contexts.

Note: This syntax may be used to indicate when the gradual construction of a named graph is finished since neither fields nor the cardinality of tabular data is preserved after this point.

=== Nested FROM and INTO subqueries

This CIP additionally proposes the introduction of nested `FROM` and `INTO` subqueries.

These subqueries support changing the source graph or the target graph for a bounded sequence of clauses without changing them for the remainder of the query.
In particular, this additional syntax helps avoid changing the source or the target graph that is returned from the query by limiting the scope of source and target graph changes.

The proposed syntax is:

[source, cypher]
----
FROM < graph-specifier > | '-' { < graph-construction-subquery > }
INTO < graph-specifier > | '-' { < graph-construction-subquery > }
----

A `<graph-construction-subquery>` is an updating subquery (i.e. a sequence of clauses, including update clauses) that may or may not end in `RETURN`.
All variables bound before the nested `FROM` and `INTO` subqueries are made visible to the `<graph-construction-subquery>`.
All variables and graphs visible at the end of the `<graph-construction-subquery>` are made visible to the remaining outer query.

These forms have the exact same effect as creating fresh aliases for the current source and target graph, then changing the current source and target graph as specified before executing the given `<graph-construction-subquery>`, and finally restoring the original source and target graphs using the aliases followed by discarding those aliases from the current scope.

=== Query signature declarations

Finally this CIP proposed using the `WITH` clause as the initial clause in a query for declaring all query inputs:

[source, cypher]
----
WITH < return-items > [ [ INPUT ] GRAPHS < graph-return-items > ]
WITH [ < return-items > ] [ INPUT ] GRAPHS < graph-return-items >
----

It is proposed that using `WITH` as the initial clause in a query is to be called a *query input declaration* while the use of `RETURN` as the last clause is to be called a *query output declaration*.

Query input declarations are subject to the following limitations:

* All return item expressions are expected to reference an imagined set of input variables from the previous query
* All such referenced variables must be declared or aliased explicitly by another return item unless the query input declaration starts with `WITH *` or `WITH *,`
* If the input query context provides additional, undeclared variables or graphs, those inputs are to be silently discarded by query composition or execution

A query that does not start with a query input declaration is assumed to start with `WITH - GRAPHS -`, i.e. to run in isolation and to initially read and write to the default graph.

== Grammar

Proposed syntax changes
[source, ebnf]
----
// TODO
----

== Examples

Example 1
[source, cypher]
----
// Query input signature: Records with fields 'a', 'b' and two graphs 'g1', 'g2'
WITH a, b GRAPHS g1, g2

// Sets source and target graph for the following statements by resolving the given physical address
// (The name of this new graph will be system generated)
FROM GRAPH AT 'graph://...'

// Creates and sets new target graph for the following statements at the given physical address
INTO NEW GRAPH result AT 'graph://...'

// Return records with 'a', 'b' and three graphs 'result', 'g1', 'g2' (query output signature)
// Source graph for future reads is again the default graph, the target graph for future writes is 'result'
RETURN a, b GRAPHS result, g1, g2
----

Example 2
[source, cypher]
----
WITH a, b GRAPHS g1, g2 ... // First query
WITH GRAPHS g3, g4 ...      // Second query over first query
RETURN c, d GRAPHS g5       // Third query over second query over first query
----

Example 3
[source, cypher]
----
FROM GRAPH persons AT 'graph://...'
MATCH (a:Person)-[r:KNOWS]->(b:Person)
MATCH (a)-[:LIVES_IN->(c:City)<-[:LIVES_IN]-(b)
INTO NEW GRAPH berlin
CREATE (a)-[:FRIEND]->(b) WHERE c.name = "Berlin"
INTO NEW GRAPH santiago
CREATE (a)-[:FRIEND]->(b) WHERE c.name = "Santiago"
FROM -
RETURN c.name AS city, count(r) AS num_friends GRAPHS berlin, santiago
----

Example 4
[source, cypher]
----
// Set scope to whole social network ...
FROM GRAPH AT 'graph://social-network'
// .. and match some data
MATCH (a:Person)-[:KNOWS]->(b:Person)-[:KNOWS]->(c:Person) WHERE NOT (a)--(c)

// Create a temporary named graph,
INTO NEW GRAPH recommendations
// containing existing nodes and new rels ...
CREATE (a)-[:POSSIBLE_FRIEND]->(c)
// ... and finally discard all tabular data and cardinality
WITH GRAPHS *

// Switch context to named graph.
FROM GRAPH recommendations
MATCH (a:Person)-[e:POSSIBLE_FRIEND]->(b:Person)
// Return tabular and graph output
RETURN a.name, b.name, count(e) AS cnt
    ORDER BY cnt DESC
    GRAPHS recommendations
----

Example 5
[source, cypher]
----
// Set scope to the whole social network ...
FROM GRAPH AT 'graph://social-network'
// .. and match some data.
MATCH (a:Person)-[:IS_LOCATED_IN]->(c:City),
      (c)->[:IS_LOCATED_IN]->(co:Country),
      (a)-[e:KNOWS]-(b)

// Create a new temporary named graph,
INTO NEW GRAPH sn_updated
// add previous matches to new graph,
CREATE (a)-[e]-(b)
// update existing nodes.
SET a.country = cn.name
// ... and finally discard all tabular data and cardinality
WITH GRAPHS *

FROM GRAPH sn_updated
MATCH (a:Person)-[e:KNOWS]->(b:Person)
WITH a.country AS a_country, b.country AS b_country, count(a) AS a_cnt, count(b) AS b_cnt, count(e) AS e_cnt
INTO NEW GRAPH rollup {
  MERGE (:Persons {country: a_country, cnt: a_cnt})-[:KNOW {cnt: e_cnt}]->(:Persons {country: b_country, cnt: b_cnt})
}
// Return final graph output
RETURN GRAPHS rollup
----

Example 5
[source, cypher]
----
// Set scope to the whole social network ...
FROM GRAPH AT 'graph://social-network'
// .. and match some data.
MATCH (a:Person)-[e]->(b:Person),
      (a)-[:LIVES_IN]->()->[:IS_LOCATED_IN]-(c:Country {name: ‘Sweden’}),
      (b)-[:LIVES_IN]->()->[:IS_LOCATED_IN]-(c)
// Create a persistent graph at 'graph://social-network/swe'
INTO NEW GRAPH sweden_people AT './swe' {
  // connecting persons that live in the same city in Sweden.
  CREATE (a)-[e]->(b)
}
// Finally discard all tabular data and cardinality
WITH GRAPHS *

MATCH (a:Person)-[e]->(b:Person),
      (a)-[:LIVES_IN]->()->[:IS_LOCATED_IN]-(c:Country {name: ‘Germany’}),
      (b)-[:LIVES_IN]->()->[:IS_LOCATED_IN]-(c)
// Create a persistent graph at 'graph://social-network/ger'
INTO NEW GRAPH german_people AT './ger' {
  // connecting persons that live in the same city in Germany.
  CREATE (a)-[e]->(b)
}
// Finally discard all tabular data and cardinality
WITH GRAPHS *

// Start query on the 'sweden_people' graph
FROM GRAPH sweden_people
MATCH p=(a)--(b)--(c)--(a) WHERE NOT (a)--(c)
// Create a temporary graph 'swedish_triangles'
INTO NEW GRAPH swedish_triangles {
  ADD p
}
// and return it together with a count of its content
RETURN count(p) AS num_triangles GRAPHS swedish_triangles, sweden_people, german_people
----

== Interaction with existing features

This proposal is far reaching as it changes both the property graph model and the execution model of the language.

However, the change has been carefully designed to not change the semantics of existing queries.

== Alternatives

The scope of this CIP could be reduced by not separating between source and target graph.

== What others do

SPARQL only provides basic facilities for returning graphs using `CONSTRUCT`.

Neither Gremlin nor PGQL have developed facilities for the direct construction and manipulation of graphs.

== Benefits to this proposal

Cypher is evolved to become a query language that is properly closed under graphs.

== Caveats to this proposal

This is a fundamental and large change to the language whose long-term consequences are difficult to assess.
