= CIP2017-04-20 - Query Combinators
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP codifies the pre-existing `UNION` and `UNION ALL` clauses as well as proposes the addition of new query combinators for set operations and pipelining.
--

toc::[]

== Motivation

Query combinators for set operators are a common feature in other query languages.
Adding more query combinators to Cypher will increase language expressivity and provide functionality that has been requested (and expected to exist) in the language by users.

== Background

The vast majority of Cypher clauses allows for sequential composition: The records produces by the first clause become an input to the following clause.
However, some operations require multiple streams of records as inputs.
These are called query combinators.
The most notable example of query combinators are set operations.

== Proposal

This CIP proposes the introduction of several new multi-arm query combinators.

* `UNION`
* `UNION MAX`
* `UNION ALL`
* `INTERSECT`
* `INTERSECT ALL`
* `EXCEPT`
* `EXCEPT ALL`
* `EXCLUSIVE UNION`
* `EXCLUSIVE UNION ALL`
* `OTHERWISE`
* `CROSS`
* `THEN`

Multi-arm query combinators can only appear as a query  using the syntax `<query> [<combinator> <query>]+`.

The `<combinator>` can be any of the combinators given above.
Multi-arm query combinators are interpreted left-associative.
Therefore in the following, we only consider combinator semantics regarding two arms (left and right).

For all proposed query combinators but not for `CROSS` and `THEN`, the following standard rules regarding returned We fields apply:

The `RETURN` clause of each arm is either a `RETURN *` or specifies record fields explicitly.
If both arms specify record fields explicitly, then they must specify the exact same set of record fields in the exact same order.
If an arm ends in `RETURN *` and the other arm specifies record fields explicitly, it must implicitly return the exact same set of record fields as the other arm.
If both arms end in `RETURN *` they must return the exact same set of record fields.
If both arms end in `RETURN *`, the order of record fields is unspecified and left to the implementation.

Multi-arm query combinators may determine the result signature of a top-level query.
If any arm specifies recod fields explicitly, the exact same set of record fields in the exact same order is returned by the whole query.

=== UNION

`UNION` computes the logical set union between two sets of input records (i.e.discards any duplicates).

`UNION MAX` computes the logical multiset union between two bags of input records (i.e. preserves the larget numer of duplicates from either arm).

`UNION ALL` computes the logical multiset union between two bags of input records (i.e. preserves all duplicates from both arms).

=== INTERSECT

`INTERSECT` computes the logical set intersection between two sets of input records (i.e.discards any duplicates).

`INTERSECT ALL` computes the logical multiset intersection between two bags of input records (i.e. preserves shared duplicates).

=== EXCEPT

`EXCEPT` computes the logical set difference between two sets of input records (i.e.discards any duplicates).

`EXCEPT ALL` computes the logical multiset difference between two bags of input records (i.e. preserves excess duplicates on the left-hand side).

=== EXCLUSIVE UNION

`EXCLUSIVE UNION` computes the exclusive logical set union between two sets of input records (i.e.discards any duplicates in the final outcome).

`EXCLUSIVE UNION ALL` computes the exclusive logical multiset union between two bags of input records (i.e. returns the largest remaining excess multiplicity of each record in any argument bag).

=== OTHERWISE

`OTHERWISE` computes the logical choice between two bags of input records.
It evaluates to all records from the left argument unless that bag is empty in which case it evaluates to all records from the right argument.

=== CROSS

`CROSS` computes the cartesian product between two bags of input records (i.e. preserves duplicates).

Contrary to the other query combinators, the standard rules regarding returned record fields do not apply to `CROSS`.
Instead, the set of returned record fields of both arms of a `CROSS` must be non-overlapping.
The finally returned record fields of a `CROSS` are the exact same fields from the left arm in the exact same order given by the left arm followed by the exact same fields from the right arm in the exact same order given by the right arm.

=== THEN

`THEN` computes query-level pipelining, i.e. it executes the right-hand query for each input record from the left-hand side and returns the flattened concatenation of all such records produced.

The main feature of `THEN` is that it allows pipelining between nested subqueries due to it's syntatic status as a query combinator.

Contrary to the other query combinators, the standard rules regarding returned record fields do not apply to `THEN`.
Instead, the set of returned record fields of both arms of `THEN` must be non-overlapping.
The finally returned record fields of a `THEN` are the exact same fields from the right arm in the exact same order given by the right arm.

=== Handling of NULL values

All query combinators perform record-level comparisons under equivalence (i.e. `NULL` is equivalent to `NULL`).

=== Interaction with existing features

This CIP codifies the pre-existing `UNION` and `UNION ALL` constructs.

The suggested changes are expected to integrate well with the parallel CIP for nested subqueries.

This CIP adds `INTERSECT`, `EXCLUSIVE`, and `OTHERWISE` as new keywords.

=== Alternatives

`EXCLUSIVE UNION` is not provided by SQL and could be omitted.

`OTHERWISE` is not provided by SQL and could be omitted.

SQL does not have `UNION MAX` (it has been suggested in the literature though).

SQL allows `MINUS` as an alias for `EXCEPT`.

== What others do

This proposal mainly follows SQL.

== Benefits to this proposal

Set operations are added to the language.

== Caveats to this proposal

Increase in language complexity; adopting controversial `NULL` handling issues from SQL.

This does not provide for aliasing of subqueries; henceforth set operations over the same argument queries need to repeat the argument subqueries.

This could be addressed in a future CIP.
