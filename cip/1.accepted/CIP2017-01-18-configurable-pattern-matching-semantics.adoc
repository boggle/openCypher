= CIP2017-01-18 - Configurable Pattern Matching Semantics
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neo4j.com>, Mats Rydberg <mats.rydberg@neo4j.com>, Petra Selmer <petra.selmer@neo4j.com>

This proposal is a response to link:https://github.com/opencypher/openCypher/issues/174[CIR-2017-174].

toc::[]

== Motivation

Currently Cypher uses pattern matching semantics that treats _all_ patterns that occur in a `MATCH` clause as a unit (called a *uniqueness scope*) and only considers pattern instances that bind different relationships to each fixed length relationship pattern variable and to each element of a variable length relationship pattern variable.
This has come to be called *Cypermorphism* informally and is a form of edge isomorphism that is based on Cypher's notion of uniqueness scope.

Cyphermorphism lies at the intersection of returning as many results as possible while still ruling out returning an infinite number of paths when matching graphs that contain cycles.

However, the notion of uniqueness scope has proven to be non-standard and is occasionally confusing for users and Cyphermorphic matching is not tractable in terms of computational complexity for some graphs.

The CIP aims to address these issues.

== Background

This CIP is based upon the notions of _walks_, _trails_ and _paths_, as defined by _Jungnickel_ <<Jung10>>.
We note that walks, trails and paths are not universally used, and correspond to _paths_, _simple paths_ and _tidy paths_ as defined by _Rosen_ <<Rose02>>.
However, we use Jungnickel's definitions as the terms lend themselves better from a syntactic perspective.

We define and provide an example for each of these terms below.
In general, we note that every path is a trail, and every trail is a walk.

Assume graph `G` is given as follows:

image::CIP2017-01-18-WTP-Graph.jpg[Graph,300,200]

For the remainder of this CIP, we use the notation `r^-^` to indicate that a relationship `r` was traversed in the inverse direction; i.e. that `r` was traversed from its target node to its source node.

[[walks]]
=== Walk

A walk is an arbitrary, non-empty sequence of alternating nodes and relationships that starts with a node and ends with a node.
Within a walk, both nodes and edges can be duplicated.
A walk whose start node and end node is the same is called a **closed walk**.

A valid walk in `G` is given by the sequence `S~1~`: `B, t, C, v, D, w, E, w^-^, D, v^-^, C, t^-^, B, s^-^, A`.

We note that `S~1~` contains the duplicated nodes `B`, `C` and `D`, and the duplicated relationships `t`, `v` and `w`.
Moreover, `S~1~` is not a _closed_ walk, as `B` (the start node) ≠ `A` (the end node).

A walk corresponds to the standard definition of _homomorphic_ graph pattern matching.

[[trails]]
=== Trail

A trail is a walk that does not contain any duplicate relationships.

A valid trail in `G` is given by the sequence `S~2~`: `B, t, C, v, D, w, E, x, F, y^-^, D, u, C`.

We note that `S~2~` contains the duplicated notes `C` and `D`, and no duplicate relationships.
Moreover, `S~2~` is not a **closed trail**, as `B` (the start node) ≠ `C` (the end node).
`S~2~` is also a walk.

A path corresponds to the standard definition of _(relationship-)isomorphic_ graph pattern matching as well as the notion of _Cyphermorphic_ graph pattern matching.

[[paths]]
=== Path

A path is a trail that does not contain the same node twice unless that node is both the start node and the end node of the path.

A valid path in `G` is given by the sequence `S~3~`: `B, t, C, v, D, y, F, z, A, s, B`.

We note that `S~3~` contains no duplicated relationships, and that there are no duplicated nodes other than `B`.
However, as `B` is both the start node and end node, `S~3~` is still a valid path, and is, in fact, an example of a **closed path**.
`S~3~` is also an example of a _closed_ walk and a _closed_ trail.

A path corresponds to the standard definition of _(node-)isomorphic_ graph pattern matching.

== Proposal

This CIP has been submitted in the belief that *CIP2017-02-06 Path Pattern Queries* will be accepted and is aligned with it.

[[syntax]]
=== Syntax

Below is outlined the syntactical changes proposed in this CIP.
Note that path patterns are assumed from the *CIP2017-02-06 Path Pattern Queries*.

.Overview of proposed grammar changes:
[source,ebnf]
----
Pattern = PatternPart, { ',', PatternPart } ;
PatternPart = [ PatternVariableSpec ], NodePattern, { (EdgePattern | PathPattern), NodePattern } ;

PatternVariableSpec = [ PatternMatchMode ], [ PatternVariableClass ], [ Variable, '=' ] ;

PatternMatchMode     = 'ALL'
                     | 'ALL SHORTEST'
                     | 'SHORTEST'
                     ;
PatternVariableClass = ([ PVClassModifier ], 'WALK', ['S'])
                     | ([ PVClassModifier ], 'TRAIL', ['S'])
                     | ([ PVClassModifier ], 'PATH', ['S'])
                     ;
PVClassModifier      = 'OPEN'
                     | 'CLOSED'
                     ;
----


As we can see above, patterns in Cypher consist of a comma-separated list of _pattern parts_, where a pattern part is exemplified by `p = (e:Employee)-[:REPORTS_TO*1..3]->(m:Manager)`.
Pattern parts may be bound to a variable, such as `p` in our example, and consist of a linear chain of connected node, relationship, and path patterns.

While Cypher allows omitting path, node, and relationship variables in a pattern, this is just syntactic sugar; i.e. all parts of a pattern should be considered to be bound to a variable name from the viewpoint of pattern matching semantics (names are either provided in the query or automatically generated by a conforming implementation).

=== Deprecations

This CIP proposes to replace the notion of *uniqueness scope* and *Cyphermorphism* and all associated rules with new, configurable pattern matching semantics.

As proposed in *CIP2017-02-06 Path Pattern Queries*, support for binding relationship list variables in variable length patterns will be deprecated.

This CIP proposes to deprecate the existing syntax for both `shortestPath` and `allShortestPaths` matching of Cypher.

=== Basic pattern matching semantics

Each pattern consists of one or more top-level pattern parts that are given in a comma separated list.

.Query 3.3.1
[source,cypher]
----
MATCH (a)-->(b), (c)<--(d)
RETURN *
----

The solution (set of successful matches) of a pattern is the cross product over the solutions of all its top-level pattern parts.
Thus, if we ignore uniqueness, Query 3.3.1 is semantically identical to Query 3.3.2.

.Query 3.3.2
[source,cypher]
----
MATCH (a)-->(b)
// sequence of matches acts like a cross product
// for each incoming row with a and b, find all matches (c)<--(d)
MATCH (c)<--(d)
RETURN *
----

Binding several nodes or relationships in a pattern to the same variable describes an implicit join.
Thus, queries 3.3.3 and 3.3.4 are semantically equivalent.

.Query 3.3.3
[source,cypher]
----
MATCH (a)-->()<--(a)-->(b)
RETURN a
----

.Query 3.3.4
[source,cypher]
----
MATCH (n1)-->(n2), (n3)<--(n4), (n5)-->(b)
WHERE n1 = n4 AND n2 = n3 AND n4 = n5
RETURN n1 AS a
----

=== Pattern variables and classes

This CIP proposes to name the variable to which a pattern part may be assigned a _pattern variable_.
Note that pattern variables are always bound to a connected sequence of node, relationship, and path patterns (see <<syntax>>).

.In the query, `p` and `q` are examples of pattern variables. A named path pattern `foo` is assumed:
[source, cypher]
----
MATCH p = (:A)-->(:B)-[:KNOWS]->(), q = (a)-/~foo/->(b)
RETURN p, q
----

Three classes of pattern variables are proposed:

* `WALK`: Pattern variables of this class may only be bound to pattern instances that are walks, as defined in <<walks>>.
* `TRAIL`: Pattern variables of this class may only be bound to pattern instances that are trails, as defined in <<trails>>.
* `PATH`: Pattern variables of this class may only be bound to pattern instances that are paths, as defined in <<paths>>.

NOTE: This CIP proposes to rename the Cypher type `PATH` to `WALK`.

.Example of using pattern variable classes for the pattern variables `p` and `q`:
[source, cypher]
----
MATCH TRAIL p = (:A)-->(:B)-[:KNOWS]->(), PATH q = (a)-/~foo/->(b)
RETURN p, q
----

The pattern variable class may be further qualified with one of the following prefixes:

* `OPEN`: This pattern variable should only be bound to walks (or trails, or paths respectively) which begin and end at _distinct_ nodes.
* `CLOSED` This pattern variable should only be bound to walks (or trails, or paths respectively) which begin and end at _the same node_.

Implementations are advised to signal a warning for uses of `OPEN` pattern variable classes where the two endpoints of the pattern both use the _same_ variable name.

Implementations are advised to signal a warning for uses of `CLOSED` pattern variable classes where the two endpoints of the pattern both use a _different_ variable name.

==== Plural forms

This CIP proposes to allow for plural forms of all pattern variable classes, which will be synonymous with their respective singular forms.
The plural forms are as follows: `WALKS`, `TRAILS`, and `PATHS`.
The main motivation is to aid readability when used in conjunction with different pattern match modes (see <<modes>>).

[[modes]]
=== Pattern match modes

This CIP proposes introducing the notion of a _pattern match mode_, that may be specified before a pattern variable in a read-only pattern (i.e. a pattern that is not used as an argument to an updating clause) and restricts the set of valid pattern matches for the subsequent pattern part.

Node patterns are unaffected by the pattern match mode, and will always match all described nodes from the graph.

==== ALL mode

This CIP proposes the new `ALL` pattern match mode that matches every walk (or trail, or path respectively) as described by all node, relationship, and path patterns given in the subsequent pattern elements.

This CIP proposes the default pattern variable class for `MATCH ALL` to be `TRAILS`.

This CIP proposes that an error should be raised for any use of the `ALL` pattern match mode without an explicit pattern variable class in combination with an unbounded variable length relationship pattern or an unbounded path pattern.

Implementations are advised to signal a warning for any use of `MATCH ALL (OPEN|CLOSED) WALKS` that may return an infinite result.

==== ALL SHORTEST mode

This CIP proposes the new `ALL SHORTEST` pattern match mode that matches every _shortest_ walk (or trail, or path respectively) as described by all node, relationship, and path patterns in the subsequent pattern elements.

This CIP proposes the default pattern variable class for `MATCH ALL SHORTEST` to be `WALKS`.

==== SHORTEST mode

This CIP proposes the new `SHORTEST` pattern match mode that matches _one shortest_ walk (or trail, or path respectively) as described by all node, relationship, and path patterns in the following pattern elements.

This CIP proposes the default pattern variable class for `MATCH SHORTEST` to be `WALKS`.

==== Default pattern match mode

This CIP proposes a new default pattern match mode that assigns a different pattern match mode and pattern variable class to each type of pattern part:

* Simple relationship patterns (e.g. `()-[]\->()`) are to be matched using `ALL TRAILS`.
* Bounded variable length relationship patterns (e.g. `()-[*2..4]\->()`) are to be matched using `ALL TRAILS`.
* Unbounded variable length relationship patterns (e.g. `()-[*]\->()`) are to be matched using `ALL TRAILS`.
* Path patterns (e.g. `()-/../\->()`) are to be matched using `ALL SHORTEST WALKS`.

This CIP proposes that an explicitly specified pattern variable class overrides the implicit pattern variable class assigned to each pattern part by using the default pattern match mode.

This CIP proposes that when using the default patter match mode without an explicitly specified pattern variable class only, all pattern parts that are to be matched as `ALL TRAILS` according to the default pattern match mode are to be matched together (i.e. may not bind the same relationship twice between them) while all other pattern parts are to be matched independently from any other pattern part.

This CIP proposes that an error should be raised for any use of the default pattern match mode without an explicit pattern variable class in combination with an unbounded variable length relationship pattern only.

Implementations are advised to signal a warning for any use of the default pattern match mode that may return an infinite result.

== Examples

The following examples demonstrates various ways in which the newly proposed constructs may be used if this CIP is adopted.

The following graph is used:

image::DataGraph.jpg[Graph,800,700]

=== Homomorphic matching using walks

We'll illustrate the benefits of the new homomorphic pattern matching by means of a series of queries.

Assume we wish to know which two people have grandchildren in common, as well as the names of the grandchildren.
Intuitively, we can see that the only two people in the graph who have grandchildren in common are _Michael Redgrave_ and _Rachel Kempson_, and that there are two grandchildren, _Natasha Richardson_ and _Jemma Redgrave_.
Although _Roy Redgrave_ is a grandfather, there is no one else in the graph who has grandchildren in common with him.

_Query 4.1.1 - Current semantics: single patterns_

[source,cypher]
----
MATCH (grandparent1:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild),
      (grandparent2:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild)
WHERE grandparent1 <> grandparent2
RETURN grandparent1.name, grandparent2.name, grandchild.name
----

Query 4.1.1 comprises two comma-separated matches which form a single pattern, `p~1~`.
As the query runs under the current semantics, relationship uniqueness (aka Cyphermorphism) is applied to `p~1~`.
This means that the `:HAS_CHILD` relationship given by `()-[:HAS_CHILD]->(grandchild)` is only traversed once, which results in no rows being returned.

_Query 4.1.2 - Current semantics: breaking the pattern to prevent the effects of Cyphermorphism_

[source,cypher]
----
MATCH (grandparent1:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild)
MATCH (grandparent2:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild)
WHERE grandparent1 <> grandparent2
RETURN grandparent1.name, grandparent2.name, grandchild.name
----

By splitting out the matches using a separate `MATCH` clause, Query 4.1.2 in effect considers two patterns, `p~2~` and `p~3~`.
Cyphermorphism is applied to `p~2~` and `p~3~` separately, which resolves the limitation inherent in Query 4.1.1.

Running Query 4.1.2 returns the following results:

[queryresult]
----
+------------------------------------------------------------+
| grandparent1.name | grandparent2.name | grandchild.name    |
+------------------------------------------------------------+
| Michael Redgrave  | Rachel Kempson    | Natasha Richardson |
| Michael Redgrave  | Rachel Kempson    | Jemma Redgrave     |
| Rachel Kempson    | Michael Redgrave  | Natasha Richardson |
| Rachel Kempson    | Michael Redgrave  | Jemma Redgrave     |
+------------------------------------------------------------+
4 rows
----

_Query 4.1.3 - New semantics: achieving homomorphism by default_

The method to achieve homomorphism as exemplified by Query 4.1.2 is undoubtedly effective, but is potentially unintuitive and contrived.
In contrast, Query 4.1.3 uses the new default semantics for simple relationship patterns, and achieves the desired result without the need to consciously manipulate the structure of the matching clause.

[source,cypher]
----
MATCH ALL WALKS (grandparent1:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild),
      (grandparent2:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild)
WHERE grandparent1 <> grandparent2
RETURN grandparent1.name, grandparent2.name, grandchild.name
----

[queryresult]
----
+------------------------------------------------------------+
| grandparent1.name | grandparent2.name | grandchild.name    |
+------------------------------------------------------------+
| Michael Redgrave  | Rachel Kempson    | Natasha Richardson |
| Michael Redgrave  | Rachel Kempson    | Jemma Redgrave     |
| Rachel Kempson    | Michael Redgrave  | Natasha Richardson |
| Rachel Kempson    | Michael Redgrave  | Jemma Redgrave     |
+------------------------------------------------------------+
4 rows
----

We could omit `ALL WALKS` from Query 4.1.3, as these are the default pattern match mode and pattern variable class, respectively, for simple relationship patterns.

_Query 4.1.4 - New semantics: achieving Cyphermorphism by default_

What happens in the scenarios where the current semantics -- i.e. Cyphermorphism -- are desirable?
All that is required is to alter the pattern variable class in the `MATCH` clause from `WALKS` to `TRAILS` (or to just add `TRAILS` if no pattern variable class was previously specified).

[source,cypher]
----
MATCH ALL TRAILS (grandparent1:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild),
      (grandparent2:Person)-[:HAS_CHILD]->()-[:HAS_CHILD]->(grandchild)
WHERE grandparent1 <> grandparent2
RETURN grandparent1.name, grandparent2.name, grandchild.name
----

Running Query 4.1.4 will return no results.

=== Matching shortest trails

[source,cypher]
----
// MATCH p=shortestPath((a)-[:X*]->()) today becomes:
MATCH SHORTEST TRAIL p = (a)-[:X*]->()
RETURN *

// MATCH p=shortestPath((a)-[:X*]->()) may be approximated using path patterns:
MATCH SHORTEST p = (a)-/:X*/->()
RETURN *

// MATCH p=allShortestPaths((a)-[:X*]->()) today becomes:
MATCH ALL SHORTEST TRAILS p = (a)-[:X*]->()
RETURN *

// MATCH p=allShortestPaths((a)-[:X*]->()) today may be approximated using path patterns:
MATCH p = (a)-/:X*/->()
RETURN *
----

=== Matching with existing semantics

Assume a function `disjoint()` defined as follows:

* `disjoint(list1, list2, ..., list_n)`: returns `true` if all argument lists are pairwise disjoint.

The function `disjoint()` may now be used to precisely express Cypher's current pattern matching semantics.

.Query 4.2.1
[source,cypher]
----
// Today (using same uniqueness scope for pat1, pat2, and pat)
MATCH pat1 = ..., pat2 = ..., pat3 = ...
RETURN *

// This CIP
MATCH TRAILS pat1 = ...
MATCH TRAILS pat2 = ...
MATCH TRAILS pat3 = ...
WITH * WHERE disjoint(rels(pat1), rels(pat2), rels(pat3))
RETURN *
----

Assuming a pre-parser option `class` which allows overriding the default pattern variable class, we may reduce the verbosity of Query 4.2.1 as in Query 4.2.2:

.Query 4.2.2
[source,cypher]
----
// Today (using same uniqueness scope for pat1, pat2, and pat)
MATCH pat1 = ..., pat2 = ..., pat3 = ...

// This CIP, using pre-parser option
CYPHER class=trails
MATCH pat1 = ...
MATCH pat2 = ...
MATCH pat3 = ...
WITH * WHERE disjoint(rels(pat1), rels(pat2), rels(pat3))
RETURN *
----

== Benefits to this proposal

This proposal adds a facility to Cypher for selecting from multiple desirable pattern matching semantics.

== Caveats to this proposal

A moderate increase in language complexity.

A change from current pattern matching semantics.
However, care has been taken to reduce the amount of broken queries and to retain access to current semantics.

`MATCH ALL [OPEN|CLOSED] WALKS` allows for non-terminating queries.

== References

[[Jung10]]
[Jung10] D. Jungnickel. _Graphs, Networks and Algorithms_. Springer Publishing Company, 2010.

[[Rose02]]
[Rose02] K. H. Rosen. _Discrete Mathematics and Its Applications_. McGraw-Hill, 2002.

[appendix]
== Functions for working with walks

Related to the concepts outlined in this CIP, but peripheral to the model and semantics described, several functions are envisioned as useful for working with the various types of patterns bound to pattern variables.
This section presents a few such functions:

* `isOpen(p)`: returns `true` if the source and target nodes of `p` are distinct.
* `isClosed(p)`: returns `true` if the source and target nodes of `p` are equal.
* `toTrail(p)`: returns `p` if `p` contains no duplicate relationships, `null` otherwise.
* `toPath(p)`: returns `toTrail(p)` if `p` contains no duplicate nodes at all or if the only two duplicate nodes are the source and target nodes of `p`, `null` otherwise.

[appendix]
== Pre-parser options

It is suggested that a conforming implementation should provide pre-parser options for defining the default pattern variable class as well as the default pattern match mode:

* `match=one of(all|all-shortest|shortest)` for configuring a different default pattern match mode
* `match=one of(walk[s]|trail[s]|path[s])` for configuring a different default pattern variable class
* `match=one of(all|all-shortest|shortest)`, `-`, `one of(walk[s]|trail[s]|path[s])` for configuring both a different default pattern match mode and a different default pattern variable class

An example of the latter would be `match=all-shortest-trails`.
