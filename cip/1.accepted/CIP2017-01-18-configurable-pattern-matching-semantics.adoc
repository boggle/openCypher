= CIP2017-01-18 - Configurable Pattern Matching Semantics
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Author:* Stefan Plantikow <stefan.plantikow@neotechnology.com>

This proposal is a response to CIR-2017-174.

== Motivation

Currently Cypher uses pattern matching semantics that treats _all_ patterns that occur in a `MATCH` clause as a unit (called a *uniqueness scope*) and only considers pattern instances that bind different relationships to each fixed length relationship pattern variable and to each element of a variable length relationship pattern variable.
This has come to be called *cypermorphism* informally and is a form of edge isomorphism that is based on Cypher's notion of uniqueness scope.

Cyphermorphism lies at the intersection of returning as many results as possible while still ruling out returning an infinite number of paths when matching graphs that contain cycles.

However, the notion of uniqueness scope has proven to be non-standard and is occasionally confusing for users and cyphermorphic matching is not tractable in terms of computational complexity for some graphs.

The CIP aims to address these issues.

== Background

This CIP relies on the terminology introduced by the openCypher grammar.

Most notably, a pattern in Cypher consists of a comma separated list of *pattern parts*.
Pattern parts may be bound to a path variable and consist of a linear chain of connected node and relationship patterns.

While Cypher allows omitting path, node, and relationship variables in a pattern this is just syntactic sugar, i.e. all parts of a pattern should be considered to be bound to a variable name from the viewpoint of pattern matching semantics (names are either provided in the query or automatically generated by a conforming implementation).

== Proposal

This CIP has been submitted in the belief that *CIP2017-02-06 Path Pattern Queries* will be accepted and is aligned with it.

=== Deprecations

This CIP proposes to replace the notion of *uniqueness scope* and *cyphermorphism* and all associated rules with new, configurable pattern matching semantics.

Likewise to what is proposed by *CIP2017-02-06 Path Pattern Queries*, support for binding relationship list variables in variable length patterns will be deprecated.

This CIP proposes to deprecate the existing syntax for both `shortestPath` and `allShortestPaths` matching of Cypher.


=== Basic pattern matching semantics

Each pattern consists of one or more top-level pattern parts that are given in a comma separated list.

.Query 3.2.1
[source,cypher]
----
MATCH (a)-->(b), (c)<--(d)
RETURN *
----

The solution (set of successful matches) of a pattern is the cross product over the solutions of all its top-level pattern parts.
Thus, if we ignore uniqueness, Query 3.2.1 is semantically identical to Query 3.2.2.

.Query 3.2.2
[source,cypher]
----
MATCH (a)-->(b)
// sequence of matches acts like a cross product
// for each incoming row with a and b, find all matches (c)<--(d)
MATCH (c)<--(d)
RETURN *
----

Binding several nodes or relationships in a pattern to the same variable describes an implicit join.
Thus, queries 3.2.3 and 3.2.4 are semantically identical.

.Query 3.2.3
[source,cypher]
----
MATCH (a)-->()<--(a)-->(b)
RETURN a
----

.Query 3.2.4
[source,cypher]
----
MATCH (n1)-->(n2), (n3)<--(n4), (n5)-->(b)
WHERE n1 = n4 AND n2 = n3 AND n4 = n5
RETURN n1 AS a
----

=== Walks

This CIP introduces the following kinds of walks:

* `WALK`: A walk is an arbitrary, non-empty sequence of alternating nodes and relationships that starts with a node and ends with a node.
* `TRAIL`: A trail is a walk that does not contain the same relationship twice.
* `PATH`: A simple path is a trail that does not contain the same node twice unless that node is both the start node and the end node of the path.

Note that every `PATH` is a `TRAIL` and that every `TRAIL` is a `WALK`.

This CIP proposes to rename the cypher type `PATH` to `WALK`.

=== Pattern variables

This CIP proposes to name the variable to which a pattern part may be assigned a *pattern variable* in the grammar.
Note that pattern variables are always bound to a connected sequence of node, relationship, and path patterns of its pattern part.

.In the query, `p` and `q` are examples of pattern variables. A named path pattern `foo` is assumed.
[source, cypher]
----
MATCH p = (:A)-->(:B)-[:KNOWS]->(), q = (a)-/~foo/->(b)
RETURN p, q
----

Three different classes of pattern variables are proposed by this CIP:

* `WALK`: This pattern variable should only be bound to a `WALK` that matches all node, relationship, and path patterns given.
* `TRAIL`: This pattern variable should only be bound to a `TRAIL` that matches all node, relationship, and path patterns given.
* `PATH`: This pattern variable should only be bound to a `PATH` that matches all node, relationship, and path patterns given.

.Example of using pattern variable classes for the pattern variables `p` and `q`:
[source, cypher]
----
MATCH TRAIL p = (:A)-->(:B)-[:KNOWS]->(), PATH q = (a)-/~foo/->(b)
RETURN p, q
----

This CIP proposes the default pattern variable class to be `WALK`.

The pattern variable class may be further qualified with one of the following prefixes:

* `OPEN`: This pattern variable should only be bound to walks (or trails, or paths respectively) which begin and end at _distinct_ nodes.
* `CLOSED` This pattern variable should only be bound to walks (or trails, or paths respectively) which begin and end at _the same node_.

Implementations are advised to signal a warning for uses of `OPEN` pattern variable classes where the two endpoints of the pattern both use the _same_ variable name.

Implementations are advised to signal a warning for uses of `CLOSED` pattern variable classes where the two endpoints of the pattern both use a _different_ variable name.

==== Synonyms and plural forms

The following additional pattern variable classes are proposed to accommodate existing terminology that is commonly used in graph theory:

* `CIRCUIT` is a synonym for `CLOSED TRAIL`
* `CYCLE` is a synonym for `CLOSED PATH`

Additionally, this CIP proposes to allow for plural forms of all pattern variable classes, which will be synonymous with their respective singular forms.
The plural forms are as follows: `WALKS`, `TRAILS`, `PATHS`, `CURCUITS`, `CYCLES`.
The main motivation is to aid readability when used in conjunction with different pattern match modes (see <<modes>>).

[[modes]]
=== Pattern match modes

.Overview of proposed grammar changes:
[source,ebnf]
----
Pattern = PatternPart, { ',', PatternPart } ;
PatternPart = [ PatternVariableSpec, '=' ], NodePattern, { (EdgePattern | PathPattern), NodePattern } ;

PatternVariableSpec = [ PatternMatchMode ], [ PBClassModifier ], [ PatternVariableClass ], Variable ;

PatternVariableClass = 'WALK'
                   | 'TRAIL'
                   | 'PATH'
                   ;
PBClassModifier    = 'OPEN'
                   | 'CLOSED'
                   ;
PatternMatchMode   = 'ALL'
                   | 'ALL SHORTEST'
                   | 'SHORTEST'
                   ;
----

This CIP proposes introducing the notion of a _pattern match mode_, that may be specified before a pattern variable in a read-only pattern (i.e. a pattern that is not used as an argument to an updating clause) and restricts the set of valid pattern matches for the subsequent pattern part.

Node patterns are unaffected by the pattern match mode, and will always match all described nodes from the graph.

==== ALL mode

This CIP proposes the new `ALL` pattern match mode that matches every walk (or trail, or path respectively) as described by all node, relationship, and path patterns given in the subsequent pattern elements.

This CIP proposes that an error should be raised for any use of the `ALL` pattern match mode without an explicit pattern variable class in combination with an unbounded variable length relationship pattern or an unbounded path pattern.

Implementations are advised to signal a warning for any use of `MATCH ALL (OPEN|CLOSED) WALKS` that may return an infinite or prohibitively large result.

==== ALL SHORTEST mode

This CIP proposes the new `ALL SHORTEST` pattern match mode that matches every _shortest_ walk (or trail, or path respectively) as described by all node, relationship, and path patterns in the subsequent pattern elements.

==== SHORTEST mode

This CIP proposes the new `SHORTEST` pattern match mode that matches _one shortest_ walk (or trail, or path respectively) as described by all node, relationship, and path patterns in the following pattern elements.

==== Default MATCH mode

This CIP proposes a new default pattern match mode that assigns a different pattern match mode to each type of pattern part:

* Simple relationship patterns (e.g. `()-[]\->()`) are to be matched using `ALL`. This is identical to `ALL SHORTEST` for simple relationship patterns.
* Bounded variable length relationship patterns (e.g. `()-[*2..4]\->()`) are to be matched using `ALL`.
* Unbounded variable length relationship patterns (e.g. `()-[*]\->()`) are to be matched using `ALL`.
* Path patterns (e.g. `()-/../\->()`) are to be matched using `ALL SHORTEST`.

This CIP proposes that an error should be raised for any use of the default pattern match mode without an explicit pattern variable class in combination with an unbounded variable length relationship pattern only.

=== Predicates and functions for working with walks

This CIP proposes to introduce additional predicates and functions for working with walks

* `isOpen(p)`: true if the start node and the end node of `p` are not the same node
* `isClosed(p)`: true if the start node and the end node of `p` are the same node
* `toTrail(p)`: `p` if `p` contains no duplicate relationships, `NULL` otherwise
* `toPath(p)`: `p` if `p` contains no duplicate relationships and either no duplicate nodes at all or the start node and the end node are the same node, `NULL` otherwise
* `toCircuit(p)`:  return `toTrail(p)` if `isClosed(p)` is true, `NULL` otherwise
* `toCycle(p)`: returns `toPath(p)` if `isClosed(p)` is true, `NULL` otherwise
* `disjoint(list1, list2, ..., list_n)` is true if the lists do not share any elements

== Examples

The following examples demonstrates various ways in which the newly proposed constructs may be used if this CIP is adopted.

=== Matching shortest paths

[source=cypher]
----
// MATCH p=shortestPath((a)-[:X*]->()) today becomes:
MATCH SHORTEST TRAIL p=(a)-[:X*]->()
RETURN *

// MATCH p=shortestPaths((a)-[:X*]->()) may be approximated using path patterns:
MATCH SHORTEST p=(a)-/:X*/->()
RETURN *

// MATCH p=allShortestPaths((a)-[:X*]->()) today becomes:
MATCH ALL SHORTEST TRAILS p=(a)-[:X*]->()
RETURN *

// MATCH p=allShortestPaths((a)-[:X*]->()) today may be approximated using path patterns:
MATCH p=(a)-/:X*/->()
RETURN *
----

=== Matching with existing semantics

`disjoint` may be used to precisely express Cypher's current pattern matching semantics.

.Query 4.2.1
[source,cypher]
----
// Today (using same uniqueness scope for pat1, pat2, and pat)
MATCH pat1=..., pat2=..., pat3=...
RETURN *

// This CIP
MATCH TRAILS pat1=...
MATCH TRAILS pat2=...
MATCH TRAILS pat3=...
WITH * WHERE disjoint(rels(pat1), rels(pat2), rels(pat3))
RETURN *
----

Assuming a pre-parser option `class` which allows overriding the default pattern variable class, we may reduce the verbosity of Query 4.2.1 as in Query 4.2.2:

.Query 4.2.2
[source,cypher]
----
// Today (using same uniqueness scope for pat1, pat2, and pat)
MATCH pat1=..., pat2=..., pat3=...

// This CIP, using pre-parser option
CYPHER class=trails
MATCH pat1=...
MATCH pat2=...
MATCH pat3=...
WITH * WHERE disjoint(rels(pat1), rels(pat2), rels(pat3))
RETURN *
----

== Benefits to this proposal

This proposal adds a facility to Cypher for selecting from multiple desirable pattern matching semantics.

== Caveats to this proposal

A moderate increase in language complexity.

A substantial departure from current pattern matching semantics.
However, care has been taken to retain access to current semantics.

`MATCH ALL [OPEN|CLOSED] WALKS` allows for non-terminating queries.
